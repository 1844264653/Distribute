## 带【yi】你【qi】吃【xue】透【xi】分布式的精髓！

什么叫分布式呢？

字面意思：就是分布式嘛

程序员肯定听过的集群，分布式，主从，主备，单点，这些模式

我举个很简单的例子吧

一家餐馆一开始很小，只需要一个厨师就ok，这个厨师负责，洗菜，择菜，切菜，炒菜，甚至端菜——单点

干了一年 了，忙不过来了，客人越来越多了【数据】，每个人点的菜都不一样了

怎么办？——多找几个厨师，人多的时候一起上，每个菜不一样，都要自己负责，洗菜，择菜，切菜，炒菜，甚至端菜——集群

又过了2年，越搞越大了这饭店，发现多个厨师，也没用，赶不上客户的需求效率了

怎么办？——招人！ 你专门洗菜的，这个专门切菜的，这个专门择菜的，这几个专门炒菜的——从不同集群里转变成分布式

效率大大提升了

————如何，这样很好理解分布式吧？分治思想！！效率提高了，老板就开心了，money噌噌噌

### 从redis到MongoDB

很多时候，一门技术甚至一种产品，最初的产生往往都来源非常简单的想法，例如2019年，我们看到DB-Engines Ranking中有两个比较熟悉的身影，MongoDB和Redis。

很有意思的是，MongoDB属于DocumentDB。如果我们调头去看DocumentDB-Engines Ranking的话，可以发现MongoDB是排在第一位，而且是以绝对性的优势“吊打”第二位到第十位（第二名只有56分），整个DB-Engines中，Oracle和MySQL的分数靠得特别近；但是在DocumentDB中，MongoDB是400多分，但第二名可能就只有100多分。

同样，Redis在K/V的领域，分数也特别靠前，它146分，第三名是MemcacheD（第二名为Amazon DynamoDB，为56分） 只有28.7分。

**为什么Redis会出现，并且成为K/VDB排名第一的一个数据库呢？**   

其实，在Redis出现之前已经有一个K/V的数据库叫Memcached，早在2003年发布，最初用Perl写了一个版本，最后用C语言重写了。在Redis没有出现之前，Memcached一直是K/V数据库的领头，为什么在2009年，当Redis出现时就飞快地代替了Memcached，直至今日，大部分的缓存我们都用Redis。**甚至刚入行的同学们根本没有听说过还有Memcached这样的数据库，这个过程中Redis到底做了什么事情？**

**事情比较简单，从设计理念出发，就是把原先Memcached的存储结构进行了改变。之前是一个Key对应一个String，然后Redis把String变化成一个可以结构化的Structured storage，也就是说Redis可以支持一些结构化的数据，包括List、sorted set、hashes等 。**

**如此小的变化为什么能够让它取得这么大的优势？关于此还是要回溯下Memcached。**

假设我们自己要设计一个缓存系统的话，设计目标与Memcached一样，过程中就需要设计一个Key String的缓存系统，那么在这个缓存系统上到底能够提供哪些服务呢？更进一步来说，当存储对象是String，针对此我们可以做到哪些操作？

​    		SET   GET   DELETE

​		    append   prepend  repclace   insert   trim   erase

​		    find    substr

​		   add    cas    gets/getlist     incr   decr

​			···

可以想见，在一个编程语言中，以以C++或者Java为例，一个字符串可以set一个字符串，还可以get一个字符串，当然也可以delete一个字符串。此外，对于字符串我们还可以做一些其他操作，例如append、prepend等，也就是字符串的尾巴和头部加些内容，甚至可以将整个字符串替换掉。当然，也可以做insert、erase，还有trim这种操作以及find、substr等。

**大家在设计过程中不妨想一想，为什么在Memcached中不支持insert或find、substr这样的操作呢？**

这其实是一个很有意思的话题。理论上Memcached可以支持这些操作，包括针对Memcached的源代码进行修改之后，也可以支持这些函数和调用，**但之所以选择不支持可能更多还是效率方面的考量。**

例如在Memcached中支持substr或者find的操作的过程中，却浪费了Memcached服务器的性能。因为find可以把整个字符串转移到本地再做find，substr也是一样，其实都归功于性能。

当然Memcached也可以提供更高级的一些操作，例如add或者一些gets操作，还可以做incr/decr，对一个数字进行原子性加减，都可以。如果去研究Memcached整个release history的话，它是2003年开始发布的一个版本，前期支持的工作是非常有限的，所以后续的高级功能也是慢慢逐渐加进去的。

再看一下Redis，可以支持的数据结构有很多，包括Strings、Lists、Sets、Sorted sets、Hashes、Bit arrays，还有HyperLogLogs、streams，streams是5.0，最新的版本甚至可以支持一些时序性的数据。

纵观整个迭代历程，Redis最初的简单想法就是能不能将Strings的结构和存储结构，让其支持的多一些。从这个想法出发，才会逐渐发展成慢慢去支持越来越多的数据结构，支持越来越多操作类型的局面。

以C++为例，一个List操作支持pop/push，也可以支持在List中间去Insert/erase。对于Redis而言，除了常见的操作之外，我看了一下Redis整体的release history，最开始的时候也支持的是一些比较简单的操作，例如pop/push；随着时间的发展，支持越来越多的高级功能，都是建立在普通的操作上。

比方说BRPOPLPUSH这个功能，就是从一个List中POP一个数据出来，插入到另外一个List中去，这算是比较高级的功能体现了，但这个也是在用户发现其需要此种场景之后才去增加的事项。

**再来探究下MongoDB。**MongoDB的“工作”其实与Redis有点类似，可以认为Redis就是利用K/V结构，**将Strings换成了一个类似于JSON的类型，JSON中可以支持的数据结构也非常多。**

MongoDB所体现的功能相似度很高。以前在设计数据库的时候，如果是关系型数据库，一开始就需要将Schema设计好，然后去做一个DDL操作。当需要增加一列或者减少一列的时候，以上的操作并不是很方便；特别在表单很庞大的情况下，操作时间会很长。

**随着业务的发展，是否可以用一个JSON来代替原型MySQL Schema？**以这样一种简单的想法出发，如今尽管MySQL或者关系型数据库还是以Schema为核心，但是MongoDB就以Document，也就是JSON这个格式为核心去构建整个数据库的功能和生态。

MySQL的常见SQL语句在MongoDB中命令长度不太一样，因为所有的命令都与JSON的格式有关，包括底层的存储结构也会因为要保存JSON格式而做出很大变化。

这部分集中想要表达的观点就是很多数据库以及技术产品的演进，其实都是有脉络可寻的，主要就是设定解决问题的目标进而完成底层数据结构的修改，其中底层结构确定之后还会在一定程度上影响产品功能，例如MongoDB在很长一段时间内都不支持事务，不是不想去尝试支持，而是取决于底层存储结构的存储引擎，无法支持事务。

同样的道理，探究Memcached和Redis的内存管理设计，也会发现，Memcached的开发者或者说社区，也想去支持像Redis一样的功能，但事实上由于底层的存储结构注定无法提供此类服务。

